/*
 *  ip2array.cpp
 *
 *  Reads a text file that contains one IPv4 address per line
 *  (e.g. 127.0.0.1) and writes to *stdout* a C‑style static const
 *  array named `untracked_ips`.  Each entry is the address in
 *  network‑byte order expressed as a 0xXXXXXXXX hexadecimal constant,
 *  ready to be #included in C or C++ source files.
 *
 *  Usage:
 *      ./ip2array <file-with-ip-list>
 *
 *  The program is deliberately simple and portable on POSIX systems.
 *  (On Windows you would need to include <winsock2.h> and call
 *   WSAStartup before using inet_pton.)
 */

#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <cstdint>
#include <cstring>      // std::strerror
#include <arpa/inet.h>  // inet_pton, AF_INET
#include <iomanip>      // std::setw, std::setfill
#include <cstddef>      // std::size_t (optional, already pulled in by other headers)

/// Trim leading and trailing whitespace (helper)
static std::string trim(const std::string& s)
{
    const char* ws = " \t\r\n";
    size_t start = s.find_first_not_of(ws);
    if (start == std::string::npos) return "";
    size_t end = s.find_last_not_of(ws);
    return s.substr(start, end - start + 1);
}

int main(int argc, char* argv[])
{
    if (argc != 2) {
        std::cerr << "Usage: " << argv[0] << " <ip‑list‑file>\n";
        return 1;
    }

    const char* filename = argv[1];
    std::ifstream in(filename);
    if (!in) {
        std::cerr << "Error opening file '" << filename << "': "
                  << std::strerror(errno) << "\n";
        return 1;
    }

    std::vector<uint32_t> ips;          // stores addresses in network order
    std::vector<std::string> ipTexts;   // original textual representation (for comments)

    std::string line;
    size_t lineNo = 0;
    while (std::getline(in, line)) {
        ++lineNo;
        line = trim(line);
        if (line.empty()) continue;               // skip blank lines
        if (line[0] == '#') continue;              // optional comment lines

        struct in_addr addr{};
        if (inet_pton(AF_INET, line.c_str(), &addr) != 1) {
            std::cerr << "Warning: line " << lineNo
                      << " is not a valid IPv4 address: '" << line << "'\n";
            continue;   // skip invalid entries
        }

        // `addr.s_addr` is already in network byte order (big‑endian)
        ips.push_back(addr.s_addr);
        ipTexts.push_back(line);
    }

    // ---- emit the C array ----
    std::cout << "/* Generated by ip2array.cpp */\n";
    std::cout << "#include <cstdint>\n\n";
    std::cout << "static const uint32_t untracked_ips[] = {\n";

    for (size_t i = 0; i < ips.size(); ++i) {
        std::cout << "    0x"
                  << std::hex << std::uppercase
                  << std::setw(8) << std::setfill('0')
                  << ips[i] << std::dec
                  << "u,  // " << ipTexts[i] << "\n";
    }

    std::cout << "};\n";
    std::cout << "\n/* Number of entries */\n";
    std::cout << "static const std::size_t untracked_ips_count = "
              << ips.size() << ";\n";

    return 0;
}
